from flask import Flask, request, render_template_string
from functools import lru_cache
import json, re, faiss, numpy as np
from sentence_transformers import SentenceTransformer

# ---- Load all code blocks from JSON dataset ----
def load_code_blocks(json_path):
    """
    Load code blocks from a JSONL dataset file.
    Supports the revised jexdataset format:
    - Format: {'file_name', 'ext', 'imports' (optional), 'code'}
    - Handles multiple JSON objects per line (split by '} {')
    - Includes imports in searchable text for better searchability
    
    For *_act.jsp files:
    - 'imports': List of imported libraries (e.g., ["jex.data.JexData", ...])
    - 'code': Code snippet content
    - 'ext': File extension (e.g., "*_act.jsp", "js")
    """
    docs, sources = [], []
    try:
        with open(json_path, "r", encoding="utf-8", errors="ignore") as f:
            content = f.read()
            # Split by '} {' pattern to handle multiple JSON objects per line
            # Note: re.split() removes the matched pattern, so we need to reconstruct
            json_objects = re.split(r'\}\s*\{', content)
            
            for obj_idx, json_str in enumerate(json_objects, 1):
                json_str = json_str.strip()
                if not json_str:
                    continue
                
                # Reconstruct complete JSON object
                # After split, first object is missing closing }, others are missing opening {
                if obj_idx == 1:
                    # First object: add closing brace if missing
                    if not json_str.endswith('}'):
                        json_str = json_str + '}'
                else:
                    # Subsequent objects: add opening brace
                    json_str = '{' + json_str
                
                # Ensure it starts with { and ends with }
                if not json_str.startswith('{'):
                    json_str = '{' + json_str
                if not json_str.endswith('}'):
                    json_str = json_str + '}'
                
                try:
                    entry = json.loads(json_str)
                    file_name = entry.get("file_name", f"unknown_{obj_idx}")
                    ext = entry.get("ext", "")
                    
                    # Get code content (support both 'code' and 'block' fields for backward compatibility)
                    code = entry.get("code", entry.get("block", "")).strip()
                    
                    # Handle imports: include them in searchable text for better searchability
                    imports = entry.get("imports", [])
                    searchable_text = code
                    
                    if imports and isinstance(imports, list) and len(imports) > 0:
                        # Add imports as searchable context at the beginning
                        imports_text = " ".join(imports)
                        searchable_text = f"Imports: {imports_text}\n\n{code}"
                    
                    # Skip empty code blocks (minimum 30 characters)
                    if len(searchable_text) > 30:
                        # Store the complete code block with imports context
                        docs.append(searchable_text)
                        sources.append(file_name)
                        
                except json.JSONDecodeError as e:
                    print(f"Error parsing JSON object {obj_idx}: {e}")
                    print(f"Problematic JSON: {json_str[:200]}...")
                except Exception as e:
                    print(f"Error processing JSON object {obj_idx}: {e}")
                    
    except FileNotFoundError:
        print(f"Error: Dataset file not found: {json_path}")
    except Exception as e:
        print(f"Error reading dataset file: {e}")
    return docs, sources

# ---- Initialize model + FAISS ----
model = SentenceTransformer("all-MiniLM-L6-v2")
docs, sources = load_code_blocks("./dataset/jexdataset.jsonl")

# Check if dataset was loaded successfully
if not docs:
    print("‚ùå Error: No code blocks loaded from dataset. Please check the dataset file.")
    print("   Expected file: ./dataset/jexdataset.jsonl")
    print("   Alternative: You can use ./dataset.jsonl (generated by search_app2.py)")
    exit(1)

embeddings = model.encode(docs, convert_to_numpy=True)
dimension = embeddings.shape[1]
index = faiss.IndexFlatL2(dimension)
index.add(embeddings)
print(f"‚úÖ Indexed {len(docs)} code blocks.")

# ---- Helper function to detect language from file extension ----
def detect_language(file_path):
    """
    Detect programming language from file extension for syntax highlighting.
    Returns Prism.js language identifier.
    """
    if not file_path:
        return "text"
    
    file_path_lower = file_path.lower()
    
    # Map file extensions to Prism.js language identifiers
    lang_map = {
        '.js': 'javascript',
        '.jsp': 'jsp',
        '.java': 'java',
        '.py': 'python',
        '.html': 'html',
        '.css': 'css',
        '.xml': 'xml',
        '.json': 'json',
        '.sql': 'sql',
        '.sh': 'bash',
        '.md': 'markdown',
        '.cpp': 'cpp',
        '.c': 'c',
        '.cs': 'csharp',
        '.php': 'php',
        '.rb': 'ruby',
        '.go': 'go',
        '.rs': 'rust',
        '.ts': 'typescript',
        '.jsx': 'jsx',
        '.tsx': 'tsx',
    }
    
    # Check for specific patterns first (JSP files - use java syntax highlighting)
    if '*_act.jsp' in file_path_lower or file_path_lower.endswith('_act.jsp') or file_path_lower.endswith('.jsp'):
        return 'java'  # JSP uses Java syntax, so use java highlighting
    
    # Check extensions
    for ext, lang in lang_map.items():
        if file_path_lower.endswith(ext):
            return lang
    
    return "text"

# ---- Search function with cache ----
@lru_cache(maxsize=50)
def search_code(query):
    query_vec = model.encode([query], convert_to_numpy=True)
    distances, indices = index.search(query_vec, 3)
    return distances, indices

# ---- Flask app ----
app = Flask(__name__)

HTML_TEMPLATE = """
    <!doctype html>
    <html>
        <head>
            <title>AI Code Search</title>
            <!-- Prism.js CSS - Dark theme matching existing style -->
            <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
            <style>
            body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; background: #f8f9fa; }
            h1 { color: #333; }
            h2 { color: #444; margin-top: 30px; }
            form { margin-bottom: 20px; }
            input { width: 100%; max-width: 800px; font-size: 14px; padding: 10px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; }
            pre { background: #2d2d2d; color: #f8f8f2; padding: 15px; border-radius: 8px; overflow-x: auto; margin: 10px 0 20px 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
            code { font-family: 'Consolas', 'Monaco', 'Courier New', monospace; font-size: 13px; line-height: 1.5; }
            .file { font-size: 13px; color: #666; margin-top: 15px; margin-bottom: 5px; font-weight: 500; }
            .result-item { margin-bottom: 30px; }
            button { padding: 10px 20px; font-size: 15px; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; }
            button:hover { background: #0056b3; }
            </style>
        </head>
        <body>
            <h1>üîç AI Code Search</h1>
            <form method="post" id="searchForm">
            <input type="text" name="query" id="query" value="{{query}}" placeholder="Type your question or code search..."><br>
            <button type="submit">Search</button>
            </form>

            {% if results %}
            <h2>Results:</h2>
            {% for res in results %}
                <div class="result-item">
                    <div class="file">{{res['file']}}</div>
                    <pre><code class="language-{{res['lang']}}">{{res['code']}}</code></pre>
                </div>
            {% endfor %}
            {% endif %}
        </body>
        <!-- Prism.js JavaScript -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script>
        const input = document.getElementById('query');
        const form = document.getElementById('searchForm');

        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
            e.preventDefault();
            console.log('Searching for:', input.value);
            form.submit();
            }
        });
        </script>
    </html>
"""

@app.route("/", methods=["GET", "POST"])
def home():
    results = []
    query = ""
    if request.method == "POST":
        query = request.form["query"].strip()
        if not query or len(query) < 2:
            return render_template_string(HTML_TEMPLATE, results=[], query=query)

        distances, indices = search_code(query)

        # Group results by file and combine code blocks
        file_results, file_scores = {}, {}
        seen_blocks = set()  # Track unique code blocks to avoid duplicates
        
        for dist, idx in zip(distances[0], indices[0]):
            file_path, code_block = sources[idx], docs[idx]
            
            # Create a unique identifier for this code block
            block_id = (file_path, code_block[:100])  # Use first 100 chars as identifier
            
            if block_id not in seen_blocks:
                seen_blocks.add(block_id)
                file_results.setdefault(file_path, []).append(code_block)
                score = 1 / (1 + dist)  # Convert distance to similarity score (better normalization)
                file_scores[file_path] = max(file_scores.get(file_path, 0), score)

        # Sort and format results with language detection
        results = [{
            "file": file_path,
            "code": "\n\n---\n\n".join(list(dict.fromkeys(code_blocks))),  # Better separator
            "score": f"{file_scores[file_path]:.3f}",
            "lang": detect_language(file_path)  # Add language for syntax highlighting
        } for file_path, code_blocks in file_results.items()]
        results = sorted(results, key=lambda r: float(r["score"]), reverse=True)

    return render_template_string(HTML_TEMPLATE, results=results, query=query)

if __name__ == "__main__":
    print("üöÄ Running on http://127.0.0.1:5000")
    app.run(debug=True)